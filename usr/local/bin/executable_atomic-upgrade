#!/bin/bash
# /usr/local/bin/atomic-upgrade
#
# Atomic system upgrade for Arch Linux on Btrfs.
# Creates a snapshot of the current root, runs a command in a chroot,
# builds a signed UKI, and registers it for next boot.

[[ $EUID -eq 0 ]] || { echo "ERROR: Must run as root" >&2; exit 1; }

set -euo pipefail

VERSION="0.0.3"

show_help() {
    cat << EOF
atomic-upgrade v${VERSION} - Atomic system upgrades for Arch Linux

Usage: atomic-upgrade [OPTIONS] [-- COMMAND...]

Options:
    -n, --dry-run    Show what would be done
    -t, --tag TAG    Custom tag for the snapshot (appended to timestamp)
    --no-gc          Skip garbage collection after upgrade
    -h, --help       Show this help
    -V, --version    Show version

Command:
    Everything after -- is executed in the snapshot chroot instead of
    the default "pacman -Syu".

Examples:
    atomic-upgrade                                  # Standard system upgrade
    atomic-upgrade -t pre-nvidia                    # Upgrade with custom tag
    atomic-upgrade --no-gc                          # Upgrade without garbage collection
    atomic-upgrade -- pacman -S nvidia              # Install specific package
    atomic-upgrade -t nvidia -- pacman -S nvidia-dkms
    atomic-upgrade --no-gc -t cleanup -- pacman -Rns firefox

EOF
    exit 0
}

case "${1:-}" in
    -h|--help) show_help ;;
    -V|--version) echo "atomic-upgrade v${VERSION}"; exit 0 ;;
esac

export ATOMIC_UPGRADE=1
source /usr/local/lib/atomic/common.sh

DRY_RUN=0
CUSTOM_TAG=""
NO_GC=0
CHROOT_CMD=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --dry-run|-n) DRY_RUN=1; shift ;;
        --tag|-t)
            [[ -n "${2:-}" ]] || { echo "ERROR: --tag requires an argument" >&2; exit 1; }
            CUSTOM_TAG="$2"
            shift 2
            ;;
        --no-gc) NO_GC=1; shift ;;
        --) shift; CHROOT_CMD=("$@"); break ;;
        -*) echo "ERROR: Unknown option: $1" >&2; exit 1 ;;
        *) echo "ERROR: Unexpected argument: $1. Use -- before commands." >&2; exit 1 ;;
    esac
done

# Validate custom tag
if [[ -n "$CUSTOM_TAG" ]]; then
    if [[ ! "$CUSTOM_TAG" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        echo "ERROR: Invalid tag '${CUSTOM_TAG}'. Use only letters, numbers, hyphens, underscores." >&2
        exit 1
    fi
    if [[ ${#CUSTOM_TAG} -gt 48 ]]; then
        echo "ERROR: Tag too long (max 48 characters)" >&2
        exit 1
    fi
fi

# Default chroot command
if [[ ${#CHROOT_CMD[@]} -eq 0 ]]; then
    CHROOT_CMD=(/usr/bin/pacman -Syu)
fi

# Verify required variables are set
[[ -n "${NEW_ROOT:-}" ]] || { echo "ERROR: NEW_ROOT not defined" >&2; exit 1; }
[[ -n "${BTRFS_MOUNT:-}" ]] || { echo "ERROR: BTRFS_MOUNT not defined" >&2; exit 1; }
[[ -n "${ESP:-}" ]] || { echo "ERROR: ESP not defined" >&2; exit 1; }

validate_config || exit 1
check_dependencies || exit 1

acquire_lock

CURRENT_SUBVOL_RAW=$(get_current_subvol_raw)
[[ -n "$CURRENT_SUBVOL_RAW" ]] || { echo "ERROR: Cannot detect current subvolume" >&2; exit 1; }
CURRENT_SUBVOL="${CURRENT_SUBVOL_RAW#/}"
GEN_ID=$(date +%Y%m%d-%H%M%S)
[[ -n "$CUSTOM_TAG" ]] && GEN_ID="${GEN_ID}-${CUSTOM_TAG}"
NEW_SUBVOL="root-${GEN_ID}"
SNAPSHOT_CREATED=0

cleanup() {
    local exit_code=$?
    set +e

    echo ":: Cleaning up..."

    # Recursive unmount handles any leftover bind mounts from arch-chroot
    if [[ -n "${NEW_ROOT:-}" ]] && mountpoint -q "$NEW_ROOT" 2>/dev/null; then
        # First try clean recursive unmount
        umount -R "$NEW_ROOT" 2>/dev/null
        # If that fails, force lazy recursive unmount
        if mountpoint -q "$NEW_ROOT" 2>/dev/null; then
            umount -Rl "$NEW_ROOT" 2>/dev/null
            sleep 1
        fi
    fi

    # On failure: remove the half-built snapshot and UKI
    if [[ $exit_code -ne 0 && ${SNAPSHOT_CREATED:-0} -eq 1 && -n "${NEW_SUBVOL:-}" ]]; then
        echo ":: Removing failed snapshot..."
        if ensure_btrfs_mounted; then
            btrfs subvolume delete "${BTRFS_MOUNT}/${NEW_SUBVOL}" 2>/dev/null || true
        fi
        [[ -n "${GEN_ID:-}" ]] && rm -f "${ESP}/EFI/Linux/arch-${GEN_ID}.efi" 2>/dev/null
    fi

    mountpoint -q "$BTRFS_MOUNT" 2>/dev/null && umount "$BTRFS_MOUNT"

    [[ -n "${LOCK_FD:-}" ]] && exec {LOCK_FD}>&- 2>/dev/null

    return $exit_code
}
trap cleanup EXIT


echo ":: Current: ${CURRENT_SUBVOL_RAW} → New: /${NEW_SUBVOL}"
echo ":: Command: ${CHROOT_CMD[*]}"

mkdir -p "$NEW_ROOT"
ensure_btrfs_mounted

echo ":: Verifying current system..."
[[ -f "/boot/vmlinuz-${KERNEL_PKG}" ]] || { echo "ERROR: No kernel: vmlinuz-${KERNEL_PKG}" >&2; exit 1; }
[[ -f "/boot/initramfs-${KERNEL_PKG}.img" ]] || { echo "ERROR: No initramfs: initramfs-${KERNEL_PKG}.img" >&2; exit 1; }

echo ":: Verifying current subvolume..."
validate_subvolume "$CURRENT_SUBVOL" || {
    echo "ERROR: Current subvolume invalid: $CURRENT_SUBVOL" >&2
    exit 1
}

echo ":: Checking disk space..."
check_btrfs_space "$BTRFS_MOUNT" 10 || exit 1
check_esp_space 250 || exit 1

if [[ "$DRY_RUN" -eq 1 ]]; then
    echo ":: DRY RUN - would create snapshot: ${NEW_SUBVOL}"
    echo ":: DRY RUN - chroot command: ${CHROOT_CMD[*]}"
    if [[ "${CHROOT_CMD[*]}" == "/usr/bin/pacman -Syu" ]]; then
        echo ":: DRY RUN - packages to upgrade:"
        /usr/bin/pacman -Syu --print 2>&1 | head -50
    fi
    echo ":: DRY RUN - would create UKI: ${ESP}/EFI/Linux/arch-${GEN_ID}.efi"
    if [[ "$NO_GC" -eq 0 ]]; then
        echo ":: DRY RUN - would run garbage collection"
    else
        echo ":: DRY RUN - garbage collection: disabled"
    fi
    echo ":: DRY RUN complete, no changes made"
    exit 0
fi

echo ":: Creating snapshot..."
btrfs subvolume snapshot "${BTRFS_MOUNT}/${CURRENT_SUBVOL}" \
    "${BTRFS_MOUNT}/${NEW_SUBVOL}"
SNAPSHOT_CREATED=1

echo ":: Mounting new root..."
ROOT_DEVICE=$(get_root_device) || { echo "ERROR: Cannot detect root device" >&2; exit 1; }

mount -o subvol="/${NEW_SUBVOL}" "$ROOT_DEVICE" "$NEW_ROOT" || {
    echo "ERROR: Failed to mount new root" >&2
    exit 1
}

mount --bind "${ESP}" "${NEW_ROOT}/efi" || {
    echo "ERROR: Failed to bind mount ESP" >&2
    exit 1
}

mount --bind "/var/cache" "${NEW_ROOT}/var/cache" || {
    echo "ERROR: Failed to bind mount cache" >&2
    exit 1
}

echo ":: Running: ${CHROOT_CMD[*]}"
arch-chroot "$NEW_ROOT" "${CHROOT_CMD[@]}" || {
    echo "ERROR: Command failed: ${CHROOT_CMD[*]}" >&2
    exit 1
}

echo ":: Updating fstab..."
update_fstab "${NEW_ROOT}/etc/fstab" "$CURRENT_SUBVOL" "$NEW_SUBVOL" || {
    echo "ERROR: Failed to update fstab" >&2
    exit 1
}
# Verification is handled inside fstab.py, but double-check here
if ! grep -q "subvol=/${NEW_SUBVOL}\|subvol=${NEW_SUBVOL}" "${NEW_ROOT}/etc/fstab"; then
    echo "ERROR: fstab update verification failed" >&2
    exit 1
fi

echo ":: Building UKI..."
UKI_PATH=$(build_uki "$GEN_ID" "$NEW_ROOT" "$NEW_SUBVOL") || exit 1

echo ":: Signing UKI for Secure Boot..."
sbctl sign "$UKI_PATH" || { echo "ERROR: Signing failed" >&2; exit 1; }

echo ":: Unmounting new root..."
umount -R "$NEW_ROOT" 2>/dev/null || true
# Mark as successful — cleanup won't delete the snapshot
SNAPSHOT_CREATED=0

if [[ "$NO_GC" -eq 0 ]]; then
    echo ":: Running garbage collection..."
    garbage_collect "$KEEP_GENERATIONS" || echo "WARN: Garbage collection had issues" >&2
else
    echo ":: Garbage collection skipped (--no-gc)"
fi

umount "$BTRFS_MOUNT" 2>/dev/null || true

echo "Generation ${GEN_ID} ready. Reboot to activate."
